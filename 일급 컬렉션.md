# 일급 컬렉션 
> 해당 MD는 [jojoldu님의 게시글](https://jojoldu.tistory.com/412) 팔로우하고 있습니다.       
   
일급 컬렉션이란, `Collection`을 `Wrapping`하면서, **그 외 다른 멤버 변수가 없는 상태를 말한다.**    
    
이러한, Wrapping 함으로써 다음과 같은 이점을 가지게 된다.
   
* 비지니스에 종속적인 자료구조
* Collection의 불변성을 보장
* 상태와 행위를 한 곳에서 관리
* 이름이 있는 컬렉션

# 비즈니스에 종속적인 자료구조   
코드에 `List<클래스>` 타입의 컬렉션이 존재한다고 가정한다.   

```java
public void methodOne() {
    List<클래스> list = createListConcrete();
    validate(list);
    // 비즈니스 로직 1
}

public void methodTwo() {
    List<클래스> list = createListConcrete();
    validate(list);    
    // 비즈니스 로직 2
}

public void methodThree() {
    List<클래스> list = createListConcrete();
    validate(list);
    // 비즈니스 로직 3
}
```
각각의 컬렉션 객체들은 비즈니스 로직을 처리하는 데 사용된다.          
그렇기에, **비즈니스 로직을 수행하기전에 알맞은 객체인지 검증 작업을 거쳐야한다.**             
이런 코드가 100개, 1000개, 10000개가 되면 이를 전부 관리할 수 있을까?        
갯수 뿐만 아니라 검증을 위해서는 이전 코드의 로직을 알고 있어야 한다.     
만약 신입 사원이 이 코드를 본다면 이를 관리할 수 있을까? 그건 힘들다고 생각한다.    
       
**컬렉션은 일종의 원시타입과 같은 객체이다.**       
자료를 저장하는데 유용한 기능을 제공해주지만, 프레임워크라는 이름 그대로   
사용자가 프레임워크의 골격에 맞춰서 코딩을 진행해야하는 부분이 있다.      
예를 들면, 6개로 갯수제한을 주고 싶어도 그러지 못한다는 것이다.   
       
그렇다면 **사용자가 원하는대로 관리해줄 수 있는 `클래스/객체`는 어디 없을까?**       
개인적으로 미리 작성된 API를 찾아서 사용하고자 하는 자세는 매우 좋다고 생각한다.        
하지만, 아쉽게도 내가 원하는 기능을 100% 가진 `클래스/객체`는 당연히 존재하지 않는다.    
                   
우리는 이 문제를 아주 쉽게 해결할 수 있다. 우리는 개발자이기 때문이다.          
내가 원하는 기능을 가진 자료구조가 없으면 만들면 되는 것이다.          
    
```java
package step4.domain.racing;

import step4.domain.car.Car;
import step4.domain.car.position.Position;
import step4.domain.ipnut.InputNames;
import step4.startegy.Move;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public final class Cars {

    private final List<Car> cars;

    public Cars(String s) {
        this(new InputNames(s));
    }

    public Cars(InputNames inputNames) {
        this(inputNames.inputNames().stream()
                .map(Car::new)
                .collect(Collectors.toList()));
    }

    public Cars(List<Car> cars) {
        validate(cars);
        this.cars = cars;
    }
   
    private final void validate(List<Car> cars) {
        if (cars == null) {
            throw new IllegalArgumentException("유효하지 않은 값을 사용했습니다.");
        }
    }

    public final void move(Move move) {
        cars.stream()
            .forEach(car -> car.move(move));
    }

    public final List<Car> cars() {
        return cars;
    }

    public final List<Car> winners(Position winnerPosition) {
        return cars.stream()
                .filter(car -> car.isWinner(winnerPosition))
                .collect(Collectors.toList());
    }

    public final Position maxPosition() {
        return cars.stream()
                .map(car -> car.position())
                .reduce(Position::winningPosition).get();
    }
```
위와 같이 특정 조건으로만 생성 할 수 있는 자료구조를 만들면 위에서 언급한 문제들이 모두 해결된다.     
`Collection`을 `Wrapping`하면서, **그 외 다른 멤버 변수가 없는 상태로 정의되어있다.**           
그리고 이런 클래스를 우린 일급 컬렉션이라고 부른다.     
               
여기서 만약, 자동차의 갯수를 6개 이하로 만든다던지, 자동차가 null인지.        
특정 자동차 움직이게 한다던지(인터페이스로 분리하여 가능하게 할 수 있다. - 엘레강트 오브젝트)           
정리하자면 기존의 컬렉션에 우리가 원하는 제약조건을 걸어두는 것은 물론 한 번에 관리할 수 있다.               
    
# 불변          
일급 컬렉션은 컬렉션의 `불변`을 보장한다.  
불변을 보장한다는 것은 `final`을 사용하는 것인가요? 라고 물어보면 반은 맞고 반은 틀리다.      
`Java`의 `final`은 정확히는 불변을 만들어주는 것은 아니며, **재할당만 금지 한다.**    

```java
    @Test
    public void final도_값변경이_가능하다() {
        //given
        final Map<String, Boolean> collection = new HashMap<>();

        //when
        collection.put("1", true);     // 값 추가 가능  
        collection.put("2", true);     // 값 추가 가능   
        collection.put("3", true);     // 값 추가 가능    
        collection.put("4", true);     // 값 추가 가능     
 
        //then
        assertThat(collection.size()).isEqualTo(4);
    }
```
위 코드와 같이 `객체를 할당`하는 것은 최초 1회밖에 못하지만,     
객체 내부의 값을 추가하거나 변경하는 작업에 대해서는 막을 수단이 없다.     
            
`Java`의 `final`은 재할당만 금지한다.         
요즘과 같이 소프트웨어 규모가 커지고 있는 상황에서 불변 객체는 아주 중요하다.     
각각의 객체들이 절대 값이 바뀔일이 없다는게 보장되면 그만큼 코드를 이해하고 수정하는데 사이드 이펙트가 최소화되기 때문이다.      
       
`Java`에서는 `final`로 그 문제를 해결할 수 없기 때문에             
`일급 컬렉션`과 `래퍼 클래스`등의 방법으로 해결해야 한다.      
그래서 아래와 같이 컬렉션의 값을 변경할 수 있는 메소드가 없는 컬렉션을 만들면 불변 컬렉션이 된다.       
    
# 상태와 행위를 한곳에서 관리      
일급 컬렉션의 세번째 장점은 **값과 로직이 함께 존재**한다는 것이다.    

```java
List<Pay> pats = Arrays.asList(
        new Pay(NAVER_PAY, 1000),
        new Pay(NAVER_PAY, 1500),
        new Pay(KAKAO_PAY, 2000),
        new Pay(TOSS, 3000L));

Long naverPaySum = pays.stream()
        .filter(pay -> pay.getPayType().equals(NAVER_PAY))
        .mapToLong(Pay::getAmount)
        .sum();       
```
일반적인 컬렉션 객체를 만들기 위해서는 객체들이 나열된 로직이 있다.        
그리고 이러한 컬렉션들을 이용하여 값을 만드는 로직도 당연히 존재한다.      
이 둘은 매우 밀접한 연관관계를 가지고 있다.   
흔히 우리가 말하는 캡슐화의 기준이 되는 응집도를 가지고 있다.     
하지만, 앞서 말했듯이 컬렉션은 원시타입과 같은 객체 자료구조이다.           
이들을 별도의 클래스로 묶어주지 않는다면, 객체지향의 원칙과 장점을 잃어버리게 된다.       
      
우선 위 코드를 기준으로 말 하자면 아래와 같다.     
    
Pay타입의 상태에 따라 지정된 메소드에서만 계산되길 원하는데, 현재 상태로는 강제할 수 있는 수단이 없다.
지금은 Pay타입의 List라면 사용될 수 있기 때문에 히스토리를 모르는 사람이라면 실수할 여지가 많다.
   
* 똑같은 기능을 하는 메소드를 중복 생성할 수 있다.
    * 히스토리가 관리 안된 상태에서 신규화면이 추가되어야 할 경우 계산 메소드가 있다는 것을 몰라 다시 만드는 경우가 빈번하다.
* 만약 기존 화면의 계산 로직이 변경 될 경우, 신규 인력은 2개의 메소드의 로직을 다 변경해야하는지, 해당 화면만 변경해야하는지 알 수 없다.
* 관리 포인트가 증가할 확률이 매우 높다.
* 계산 메소드를 누락할 수 있다.
* 리턴 받고자 하는 것이 Long 타입의 값이기 때문에 꼭 이 계산식을 써야한다고 강제할 수 없다
           
결국에 네이버페이 총 금액을 뽑을려면 이렇게 해야한다는 계산식을 컬렉션과 함께 두어야 한다.
만약 네이버페이 외에 카카오 페이의 총금액도 필요하다면 더더욱 코드가 흩어질 확률이 높다.
    
**이러한 문제점도 일급 컬렉션을 이용하여 해결할 수 있다.**      
```java
public class PayGroups {
    private List<Pay> pays;

    public PayGroups(List<Pay> pays) {
        this.pays = pays;
    }

    public Long getNaverPaySum() {
        return pays.stream()
                .filter(pay -> PayType.isNaverPay(pay.getPayType()))
                .mapToLong(Pay::getAmount)
                .sum();
    }
}
```
일급 컬렉션은 하나의 클래스이자 객체이자   
즉, 역할과 책임만 잘 나눈다면, 연관된 기능들을 묶어서 클래스 단위로 관리할 수 있다.      

만약 다른 결제 수단들의 합이 필요하다면 아래와 같이 람다식으로 리팩토링 가능하다.   
   
```java
public class PayGroups {
    private List<Pay> pays;

    public PayGroups(List<Pay> pays) {
        this.pays = pays;
    }

    public Long getNaverPaySum() {
        return getFilteredPays(pay -> PayType.isNaverPay(pay.getPayType()));
    }

    public Long getKakaoPaySum() {
        return getFilteredPays(pay -> PayType.isKakaoPay(pay.getPayType()));
    }

    private Long getFilteredPays(Predicate<Pay> predicate) {
        return pays.stream()
                .filter(predicate)
                .mapToLong(Pay::getAmount)
                .sum();
    }
}
```   
   
**결과**    
```java

```




  
